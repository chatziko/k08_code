
### generic_lists

Επίδειξη διαφορετικών λύσεων για χρήση λιστών **διαφορετικών τύπων** (λίστας από strings και λίστας από ακεραίους)
στο **ίδιο πρόγραμμα**.

#### Usage

```
cd demo_union
make run

cd demo_voidpointer
make run

cd demo_untyped
make run

cd demo_template
make run
```

#### Περιγραφή

Στη C μπορούμε να φτιάξουμε μια λίστα από items αυθαίρετου τύπου βάζοντας το item να έχει
τύπο LLItem τον οποίο ορίζει ο χρήστης με typedef. Μια τέτοια λίστα λέγεται **"typed"**, γιατί
ο compiler γνωρίζει τον τύπο του item και ελέγχει ότι τον περνάμε σωστά (μας βοηθάει δηλαδή
να εντοπίζουμε λάθη).

Τι γίνεται όμως αν **στο ίδιο πρόγραμμα** θέλουμε μια λίστα από strings, και **ταυτόχρονα** μια λίστα
από ints; Προφανώς δεν μπορεί το LLItem να είναι ταυτόχρονα char* και int! **Δε θέλουμε όμως
να ξαναγράφουμε τον ίδιο κώδικα** για κάθε λίστα!

Δυστυχώς η C δεν παρέχει μια 100% ικανοποιητική λύση, πάρα ταύτα υπάρχουν αρκετές επιλογές για να
επιτευχτεί αυτός ο στόχος, ορισμένες απο τις οποίες επιδευκνύονται σε αυτό το project.

#### Λύση 1 : LLItem = union

Ενα union είναι σαν ένα struct το οποίο όμως αποθηκεύει **ένα** από τα πεδία τη φορά (όχι όλα μαζί).
Οπότε μια απλή λύση είναι να ορίσουμε
```
typedef union {
	char* string;	// store strings here
	int integer;	// store ints here
} LLItem;
```
Αν θέλουμε λίστα από ακεραίους χρησιμοποιούμε απλά το ```.integer``` πεδίο του union, διαφορετικά
το ```.string``` πεδίο. (Πρέπει βέβαια εμείς να θυμόμαστε τι από τα δύο χρησιμοποιούμε, η C
δεν μας το λέει αυτό.)

Η λύση αυτή επιδεικνύεται στο [demo_union](demo_union)
(χρησιμοποιώντας την υλοποίηση λίστας του [list_typed](modules/list_typed) module).

- Θετικά
  - Απλή λύση
  - Ακόμα και με τους πολλαπλούς τύπους η λίστα παραμένει "semi-typed" : o compiler ελέγχει
  ότι το ```item.integer``` είναι πάντα ακέραιος (αλλά εμείς πρέπει να επιλέξουμε σωστά το πεδίο).
- Αρνητικά
  - Το μέγεθος του union είναι ίσο με το μέγεθος του **μεγαλύτερου** πεδίου του. Οπότε αν κάποια
  από τις λίστες που θέλουμε έχει μεγάλο item, τότε **όλες** θα έχουν μεγάλο item, σπαταλώντας χώρο.
  - Ολοι οι χρήστες της λίστας πρέπει να "συντονιστούν" για να ορίσουν το εννιαίο LLItem.


#### Λύση 2 : LLItem = void*

Αντί να αποθηκεύουμε τα δεδομένα αποθηκεύουμε **pointers σε αυτά**! Οποιοσδήποτε pointer
μπορεί να γίνει cast σε void* οπότε θέτωντας LLItem = void* μπορούμε να αποθηκεύσουμε
διαφορετικών τύπων δεδομένα.

Η λύση αυτή επιδεικνύεται στο [demo_voidpointer](demo_voidpointer)
(χρησιμοποιώντας την υλοποίηση λίστας του [list_typed](modules/list_typed) module).

- Θετικά
  - Σχετικά απλή λύση
- Αρνητικά
  - Η χρήση της λίστας με αυτόν τον τρόπο είναι ουσιαστικά untyped
  (αλλά διατηρούμε τη δυνατότητα να χρησιμοποιήσουμε τη λίστα με typed τρόπο σε άλλα προγράμματα).
  - Μέρος του memory management περνάει στο χρήστη. ΕΦόσον αποθηκεύουμε ένα pointer στον ακέραιο
  42, και όχι το ίδιο το 42, πρέπει εμείς να κάνουμε malloc, να βάλουμε το 42 στη μνήμη, να
  αποθηκεύσουμε τον pointer στη λίστα, και να κάνουμε free μετά.


#### Λύση 3 : untyped list

Χρησιμοποιούμε μια πλήρως untyped λίστα. Δεν υπάρχει δηλαδή LLItem καθόλου.
Αντί να γνωρίζει τον τύπο του item, η λίστα γνωρίζει μόνο το _μέγεθος_ ```item_size``` του τύπου (όρισμα στην Create). Σε κάθε insert η λίστα παίρνει έναν pointer (void*) στα δεδομένα,
και τα **αντιγράφει** στον κόμβο (**δεν αποθηκεύει pointers** δηλαδή, αλλά τα ίδια τα δεδομένα).

Μια untyped υλοποίηση λίστας υπάρχει στο [list_untyped](modules/list_untyped) module,
και επιδεικνύεται στο [demo_untyped](demo_untyped).

- Θετικά
  - Ολο το memory management γίνεται από τη λίστα
  - Εφόσον είναι untyped, η λίστα μπορεί να δοθεί στο χρήστη σε **compiled** μορφή
  (αυτό δεν γίνεται σε typed lists γιατί κατά το compilation πρέπει να είναι γνωστό
  το LLItem το οποίο όμως το δίνει ο χρήστης!)
- Αρνητικά
  - fully untyped λύση (δεν υπάρχει καμία δυνατότητα για typed items)


#### Λύση 4 : template list

Τα templates της C++ είναι ένα feature που κάνει ακριβώς αυτό που θέλουμε : επιτρέπει
τη δημιουργία δομών με ``παράμετρο'' τον τύπο. Δυστυχώς αυτό δεν είναι ακριβώς C, αλλά
από την άλλη η C++ είναι (σχεδόν) υπερσύνολο της C. Οπότε μπορούμε να γράφουμε κανονικά C κώδικα
και να χρησιμοποιήσουμε **μόνο τα templates** της C++, χωρίς κανένα άλλο από τα πιο προχωρημένα
features της. Αυτή τη γλώσσα θα μπορούσαμε να την ονομάσουμε "template-C", η χρήση
templates ελάχιστα αλλάζει τη μορφή του κώδικα όπως την ξέρουμε στη C.

Με τη χρήση templates δεν υπάρχει πια `LLItem`, και η λίστα από `LLList` γίνεται `LLList<T>`, όπου `T`
ο τύπος του item. Και μπορούμε να χρησιμοποιούμε λίστες `LLList<int>`, `LLList<char*>`, κλπ, στο ίδιο
πρόγραμμα.

Κατά τα άλλα ο κώδικας αλλάζει μόνο στη δήλωση των structs και των συναρτήσεων με "template" τρόπο,
έχοντας δηλαδή πάντα μια παράμετρο `T`. Πχ
```
template<typename T>          // a template struct! T is a type parameter
struct mystruct {
    T item;                   // item, of type T
};
```
Οι συναρτήσεις μπορούν επίσης να έχουν έναν τύπο ως παράμετρο:
```
template<typename T>    // a template function! T is a type parameter
T foo(T a) {            // takes an argument of type T, returns a value of type T
  return a + 1;
}
```
και καλούνται ως
```
foo<int>(15);       // returns 16
foo<double>(5.3);   // returns 6.3
```
Το `<int>` στις κλήσεις `foo<int>` μπορεί συχνά να παραλειφθεί αν ο compiler μπορεί να καταλάβει
τον τύπο από τα ορίσματα της συνάρτησης!

Κατά τα άλλα ο κώδικας αλλάζει ελάχιστα. Μια διαφορά είναι ότι **όλος ο κώδικας υπάρχει
στο .h αρχείο** (δεν υπάρχει .c), και πρέπει βέβαια να κάνουμε compile με g++, όχι gcc.

Μια template υλοποίηση λίστας υπάρχει στο [list_template](modules/list_template) module,
και επιδεικνύεται στο [demo_template](demo_template).

- Θετικά
  - Fully typed
  - Σχετικά απλός κώδικας, με λίγες αλλαγές σε σχέση με την non-template version
- Αρνητικά
  - Δεν είναι pure C